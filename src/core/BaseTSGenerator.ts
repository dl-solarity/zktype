import fs from "fs";
import path from "path";
import ts from "typescript";

import CircuitArtifactGenerator from "./CircuitArtifactGenerator";

import { CircuitArtifact, ZKTypeConfig } from "../types";

/**
 * `BaseTSGenerator` is a base class for all TypeScript generators.
 *
 * It exposes common properties and methods that are shared among all TypeScript generators.
 */
export default class BaseTSGenerator {
  /**
   * This separator is needed to distinguish between generated types and auxiliary generated files.
   */
  public static readonly DOMAIN_SEPARATOR: string = "core";

  protected readonly _zktypeConfig: ZKTypeConfig;

  protected readonly _projectRoot: string;

  protected readonly _printer: ts.Printer;
  protected readonly _resultFile: ts.SourceFile;

  protected readonly _artifactsGenerator: CircuitArtifactGenerator;

  constructor(config: ZKTypeConfig) {
    this._zktypeConfig = config;

    this._artifactsGenerator = new CircuitArtifactGenerator(config);

    this._projectRoot = config.projectRoot;

    this._printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
    this._resultFile = ts.createSourceFile("", "", ts.ScriptTarget.Latest, false, ts.ScriptKind.TS);
  }

  /**
   * Returns the path to the output directory for the generated TypeScript files.
   */
  public getOutputTypesDir(): string {
    const relativePath: string = this._zktypeConfig.outputTypesDir ?? "generated-types/circuits";

    return path.join(this._projectRoot, relativePath);
  }

  /**
   * Returns the path to the output directory for the generated artifacts.
   */
  public getOutputArtifactsDir(): string {
    return this._artifactsGenerator.getOutputArtifactsDir();
  }

  /**
   * Saves the content to the file with the given name.
   *
   * @param {string} typePath - The path to the file to be saved.
   * @param {string} content - The content to be saved.
   */
  protected _saveFileContent(typePath: string, content: string): void {
    if (!fs.existsSync(path.join(this.getOutputTypesDir(), path.dirname(typePath)))) {
      fs.mkdirSync(path.join(this.getOutputTypesDir(), path.dirname(typePath)), {
        recursive: true,
      });
    }

    fs.writeFileSync(path.join(this.getOutputTypesDir(), typePath), [this._getPreamble(), content].join("\n\n"));
  }

  /**
   * Returns the source file content for the given node.
   *
   * @param {ts.Node} node - The node for which the source file content is generated.
   * @returns {string} The generated source file content.
   */
  protected _getNodeContent(node: ts.Node): string {
    return this._printer.printNode(ts.EmitHint.Unspecified, node, this._resultFile);
  }

  /**
   * Extracts the type name from the circuit artifact.
   *
   * @param {CircuitArtifact} circuitArtifact - The circuit artifact from which the type name is extracted.
   * @param {string} [prefix=""] - The prefix to be added to the type name.
   * @returns {string} The extracted type name.
   */
  protected _getTypeName(circuitArtifact: CircuitArtifact, prefix: string = ""): string {
    return `${prefix}${circuitArtifact.circuitName.replace(path.extname(circuitArtifact.circuitName), "")}`;
  }

  /**
   * Extracts the circuit name from the circuit artifact.
   *
   * @param {CircuitArtifact} circuitArtifact - The circuit artifact from which the circuit name is extracted.
   * @returns {string} The extracted circuit name.
   */
  protected _getCircuitName(circuitArtifact: CircuitArtifact): string {
    return `${circuitArtifact.circuitName.replace(path.extname(circuitArtifact.circuitName), "")}`;
  }

  /**
   * Returns the full circuit name.
   *
   * The full circuit name is a combination of the source name and the circuit name, separated by a colon.
   *
   * @param {CircuitArtifact} circuitArtifact - The circuit artifact from which the full circuit name is extracted.
   * @returns {string} The full circuit name.
   */
  protected _getFullCircuitName(circuitArtifact: CircuitArtifact): string {
    return `${circuitArtifact.sourceName}:${this._getCircuitName(circuitArtifact)}`;
  }

  /**
   * Returns the preamble for the generated file.
   */
  protected _getPreamble(): string {
    const preambleNodes = [
      "/* Autogenerated file. Do not edit manually. */",
      "// @ts-nocheck",
      "/* tslint:disable */",
      "/* eslint-disable */",
    ];

    return preambleNodes.join("\n");
  }

  /**
   * Returns the long path to the circuit type.
   *
   * The long path is the path that includes the source name and the circuit name.
   */
  protected _getCircuitTypeLongPath(basePath: string, sourceName: string, circuitName: string): string {
    return path.join(BaseTSGenerator.DOMAIN_SEPARATOR, sourceName.replace(basePath, ""), `${circuitName}.ts`);
  }

  /**
   * Returns the short path to the circuit type.
   *
   * The short path is the path that includes ONLY the circuit name.
   */
  protected _getCircuitTypeShortPath(basePath: string, sourceName: string, circuitName: string): string {
    return path
      .join(BaseTSGenerator.DOMAIN_SEPARATOR, sourceName.replace(basePath, ""))
      .replace(path.basename(sourceName), `${circuitName}.ts`);
  }

  /**
   * Returns the path to the generated file for the given circuit.
   *
   * The path can be either long or short, depending on the existence of the long path.
   */
  protected _getPathToGeneratedFile(basePath: string, sourceName: string, circuitName: string): string {
    const longObjectPath = this._getCircuitTypeLongPath(basePath, sourceName, circuitName);
    const shortObjectPath = this._getCircuitTypeShortPath(basePath, sourceName, circuitName);

    const isLongPathExist = this._checkIfCircuitExists(longObjectPath);
    const isShortPathExist = this._checkIfCircuitExists(shortObjectPath);

    if (!isLongPathExist && !isShortPathExist) {
      throw new Error(`Circuit ${circuitName} type does not exist.`);
    }

    return isLongPathExist ? longObjectPath : shortObjectPath;
  }

  /**
   * Checks if the circuit name is fully qualified.
   */
  protected _isFullyQualifiedCircuitName(circuitName: string): boolean {
    return circuitName.includes(":");
  }

  /**
   * Checks if the circuit exists.
   *
   * Expects to get the path to the circuit file, relative to the directory where the generated types are stored.
   */
  protected _checkIfCircuitExists(pathToCircuit: string): boolean {
    const pathFromRoot = path.join(this.getOutputTypesDir(), pathToCircuit);

    return fs.existsSync(pathFromRoot);
  }
}
