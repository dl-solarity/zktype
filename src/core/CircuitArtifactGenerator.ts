import fs from "fs";
import path from "path";

import CircuitProcessor from "./CircuitProcessor";
import CircuitASTGenerator from "./CircuitASTGenerator";

import { findProjectRoot } from "../utils";

import { defaultCircuitProcessorConfig } from "../config";

import { InternalType, SignalTypeNames, SignalVisibilityNames } from "../constants";
import {
  Stmt,
  Signal,
  CircuitAST,
  SignalType,
  Declaration,
  CircuitArtifact,
  SignalVisibility,
  CircomCompilerOutput,
  CircuitProcessorConfig,
  CircuitArtifactGeneratorConfig,
} from "../types";

/**
 * `CircuitArtifactGenerator` is responsible for generating circuit artifacts based on the ASTs generated by the `CircuitASTGenerator`.
 *
 * The artifact is a JSON file which can be used further in the pipeline for type generation, strict typing natively by TypeScript, etc.
 * If the format of the artifact changes, the `CURRENT_FORMAT` constant should be updated for backward compatibility.
 *
 * This class mainly parses and validates the generated AST JSONs. Validation is needed to ensure that the generated AST files meet expectations and necessary
 * fields exist.
 * @todo Consider using a class for filtering which circuits to compile for caching purposes.
 */
export default class CircuitArtifactGenerator {
  /**
   * The directory where the generated artifacts will be stored.
   */
  public static readonly ARTIFACTS_DIR: string = "artifacts/circuits";

  /**
   *  The current format version of the circuit artifact.
   */
  public static readonly CURRENT_FORMAT: string = "zktype-circom-artifact-1";

  private readonly _projectRoot: string;
  private readonly _circuitArtifactGeneratorConfig: CircuitArtifactGeneratorConfig;

  private readonly _circuitPreprocessor: CircuitProcessor;

  /**
   * Creates an instance of CircuitArtifactGenerator.
   * @param {CircuitArtifactGeneratorConfig} circuitArtifactGeneratorConfig - The configuration for the `CircuitArtifactGenerator`.
   * @param {CircuitProcessorConfig} [circuitProcessorConfig=defaultCircuitProcessorConfig] - The configuration for the `CircuitProcessor`.
   */
  constructor(
    circuitArtifactGeneratorConfig: CircuitArtifactGeneratorConfig,
    circuitProcessorConfig: CircuitProcessorConfig = defaultCircuitProcessorConfig,
  ) {
    this._projectRoot = findProjectRoot(process.cwd());
    this._circuitArtifactGeneratorConfig = circuitArtifactGeneratorConfig;

    this._circuitPreprocessor = new CircuitProcessor(circuitProcessorConfig);
  }

  /**
   * Generates circuit artifacts based on the ASTs.
   */
  public async generateCircuitArtifacts(): Promise<void> {
    await this._circuitPreprocessor.processCircuits();

    const astFilePaths = this._fetchASTFilePaths();

    if (this._circuitArtifactGeneratorConfig.clean) {
      this._cleanArtifacts();
    }

    for (const astFilePath of astFilePaths) {
      const circuitArtifact = await this._extractArtifact(astFilePath);

      this._saveArtifact(circuitArtifact);
    }
  }

  /**
   * Fetches the file paths of the generated AST JSON files.
   *
   * If the file path does not have an extension or the extension is not `.json`, it will be ignored.
   *
   * @returns {string[]} An array of file paths.
   */
  private _fetchASTFilePaths(): string[] {
    const files = fs.readdirSync(CircuitASTGenerator.TEMP_DIR, { recursive: true });

    const astFiles: string[] = [];

    for (const file of files) {
      const filePath = file.toString();

      if (!path.extname(filePath) || !path.extname(filePath).includes(".json")) {
        continue;
      }

      astFiles.push(filePath);
    }

    return astFiles;
  }

  /**
   * Extracts the artifact information from the AST JSON file.
   *
   * All the fields that are required for the artifact are extracted from the AST are validated.
   *
   * @param {string} pathToTheAST - The path to the AST JSON file.
   * @returns {Promise<CircuitArtifact>} A promise that resolves to the extracted circuit artifact.
   */
  private async _extractArtifact(pathToTheAST: string): Promise<CircuitArtifact> {
    const ast: CircuitAST = JSON.parse(
      fs.readFileSync(path.resolve(CircuitASTGenerator.TEMP_DIR, pathToTheAST), "utf-8"),
    );

    this._validateCircuitAST(ast);

    const circuitArtifact: CircuitArtifact = {
      _format: CircuitArtifactGenerator.CURRENT_FORMAT,
      circuitName: ast.circomCompilerOutput[0].main_component![1].Call.id,
      sourceName: ast.sourcePath,
      compilerVersion: ast.circomCompilerOutput[0].compiler_version.join("."),
      signals: [],
    };

    for (const statement of ast.circomCompilerOutput[0].definitions[0].Template!.body.Block.stmts) {
      if (
        !statement.InitializationBlock ||
        !this._validateInitializationBlock(ast.sourcePath, statement.InitializationBlock) ||
        statement.InitializationBlock.xtype.Signal[0] === SignalTypeNames.Intermediate
      ) {
        continue;
      }

      const signal: Signal = {
        type: statement.InitializationBlock.xtype.Signal[0] as SignalType,
        internalType: this._getInternalType(statement.InitializationBlock.initializations[0].Declaration),
        visibility: this._getSignalVisibility(ast.circomCompilerOutput[0], statement),
        name: statement.InitializationBlock.initializations[0].Declaration.name,
      };

      circuitArtifact.signals.push(signal);
    }

    return circuitArtifact;
  }

  /**
   * Saves the circuit artifact to a JSON file.
   *
   * @param {CircuitArtifact} artifact - The circuit artifact to be saved.
   */
  private _saveArtifact(artifact: CircuitArtifact): void {
    const circuitArtifactPath = path
      .join(
        this._projectRoot,
        CircuitArtifactGenerator.ARTIFACTS_DIR,
        artifact.sourceName.replace(this._circuitPreprocessor.getDefaultFolder(), ""),
      )
      .replace(path.extname(artifact.sourceName), ".json");

    fs.mkdirSync(circuitArtifactPath.replace(path.basename(circuitArtifactPath), ""), { recursive: true });

    fs.writeFileSync(circuitArtifactPath, JSON.stringify(artifact, null, 2));
  }

  /**
   * Cleans the artifacts directory by removing all files and subdirectories.
   */
  private _cleanArtifacts(): void {
    const artifactsDir = path.join(this._projectRoot, CircuitArtifactGenerator.ARTIFACTS_DIR);

    if (fs.existsSync(artifactsDir)) {
      fs.rmSync(artifactsDir, { recursive: true, force: true });
    }
  }

  /**
   * Determines the internal type of declared variable based on its dimensions.
   *
   * This method checks if the declared variable has dimensions. If the variable has non-empty dimensions,
   * it is considered an array.
   *
   * @param {Declaration} declaration - The declaration to check.
   * @returns {string} The internal type of the declared variable, either 'bigint' or 'bigint[]'.
   */
  private _getInternalType(declaration: Declaration): string {
    if (declaration.dimensions.length > 0) {
      return InternalType.BigIntArray;
    }

    return InternalType.BigInt;
  }

  /**
   * Determines the visibility of a signal based on the circuit compiler output and the statement.
   *
   * If the signal is used in the main component or is an output signal, it is considered public.
   *
   * @param {CircomCompilerOutput} compilerOutput - The compiler output of the circuit.
   * @param {Stmt} statement - The statement to check.
   * @returns {SignalVisibility} The visibility of the signal.
   */
  private _getSignalVisibility(compilerOutput: CircomCompilerOutput, statement: Stmt): SignalVisibility {
    const signalName = statement.InitializationBlock!.initializations[0].Declaration.name;

    if (
      compilerOutput.main_component![0].includes(signalName) ||
      statement.InitializationBlock?.initializations[0].Declaration.xtype.Signal[0] === SignalTypeNames.Output
    ) {
      return SignalVisibilityNames.Public;
    }

    return SignalVisibilityNames.Private;
  }

  /**
   * Validates the AST of a circuit to ensure it meets the expected structure.
   *
   * @param {CircuitAST} ast - The AST of the circuit to be validated.
   *
   * @throws {Error} If the AST does not meet the expected structure.
   */
  private _validateCircuitAST(ast: CircuitAST): void {
    if (
      ast.circomCompilerOutput.length < 1 ||
      !ast.circomCompilerOutput[0].main_component ||
      ast.circomCompilerOutput[0].main_component.length < 2 ||
      !ast.circomCompilerOutput[0].main_component[1].Call
    ) {
      throw new Error(`The main component is missing or incomplete in the circuit AST: ${ast.sourcePath}`);
    }

    if (!ast.circomCompilerOutput[0].compiler_version) {
      throw new Error(`The compiler version is missing in the circuit AST: ${ast.sourcePath}`);
    }

    if (!ast.circomCompilerOutput[0].main_component[1].Call.id) {
      throw new Error(`The main component id is missing in the circuit AST: ${ast.sourcePath}`);
    }

    if (
      !ast.circomCompilerOutput[0].definitions[0].Template ||
      !ast.circomCompilerOutput[0].definitions[0].Template.body ||
      !ast.circomCompilerOutput[0].definitions[0].Template.body.Block ||
      !ast.circomCompilerOutput[0].definitions[0].Template.body.Block.stmts
    ) {
      throw new Error(`The template is missing or incomplete in the circuit AST: ${ast.sourcePath}`);
    }
  }

  /**
   * Validates the initialization block in the circuit AST.
   *
   * @param {string} astSourcePath - The source path of the AST.
   * @param {any} initializationBlock - The initialization block to be validated.
   *
   * @returns {boolean} Returns `true` if the initialization block is valid, `false` otherwise.
   * @throws {Error} If the initialization block is missing required fields.
   */
  private _validateInitializationBlock(astSourcePath: string, initializationBlock: any): boolean {
    if (!initializationBlock.xtype) {
      throw new Error(`The initialization block xtype is missing in the circuit AST: ${astSourcePath}`);
    }

    if (
      !initializationBlock.initializations ||
      initializationBlock.initializations.length < 1 ||
      !initializationBlock.initializations[0].Declaration ||
      !initializationBlock.initializations[0].Declaration.name
    ) {
      throw new Error(
        `The initializations field of initialization block is missing or incomplete in the circuit AST: ${astSourcePath}`,
      );
    }

    if (!initializationBlock.xtype.Signal || initializationBlock.xtype.Signal.length < 1) {
      return false;
    }

    return true;
  }
}
